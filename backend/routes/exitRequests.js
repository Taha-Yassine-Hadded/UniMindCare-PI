const express = require("express");
const { body, validationResult } = require("express-validator");
const ExitRequest = require("../Models/ExitRequest");
const User = require("../Models/Users");
const jwt = require("jsonwebtoken");
const router = express.Router();

// Middleware Ã©tudiant
const authenticateStudent = async (req, res, next) => {
  const token = req.headers.authorization?.split(" ")[1];
  if (!token) return res.status(401).json({ message: "Token manquant" });

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    const user = await User.findById(decoded.userId);
    if (!user) {
      return res.status(403).json({ message: "Utilisateur non trouvÃ©" });
    }
    // VÃ©rifier le rÃ´le en tenant compte d'une valeur chaÃ®ne ou tableau
    let isStudent = false;
    if (Array.isArray(user.Role)) {
      isStudent = user.Role.map(r => r.toLowerCase()).includes("student");
    } else if (typeof user.Role === "string") {
      isStudent = user.Role.toLowerCase() === "student";
    }
    // On peut aussi vÃ©rifier le tableau user.roles s'il existe
    if (!isStudent && user.roles && Array.isArray(user.roles)) {
      isStudent = user.roles.map(r => r.toLowerCase()).includes("student");
    }
    if (!isStudent) {
      return res.status(403).json({ message: "AccÃ¨s refusÃ© : rÃ©servÃ© aux Ã©tudiants" });
    }
    req.user = user;
    next();
  } catch (error) {
    console.error("Erreur d'authentification:", error);
    return res.status(401).json({ message: "Token invalide ou expirÃ©" });
  }
};

// Middleware enseignant
const authenticateTeacher = async (req, res, next) => {
  const token = req.headers.authorization?.split(" ")[1];
  if (!token) return res.status(401).json({ message: "Token manquant" });

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    const user = await User.findById(decoded.userId);
    if (!user) {
      return res.status(403).json({ message: "Utilisateur non trouvÃ©" });
    }
    let isTeacher = false;
    if (Array.isArray(user.Role)) {
      isTeacher = user.Role.map(r => r.toLowerCase()).includes("teacher");
    } else if (typeof user.Role === "string") {
      isTeacher = user.Role.toLowerCase() === "teacher";
    }
    if (!isTeacher && user.roles && Array.isArray(user.roles)) {
      isTeacher = user.roles.map(r => r.toLowerCase()).includes("teacher");
    }
    if (!isTeacher) {
      return res.status(403).json({ message: "AccÃ¨s refusÃ© : rÃ©servÃ© aux enseignants" });
    }
    req.user = user;
    next();
  } catch (error) {
    console.error("Erreur d'authentification:", error);
    return res.status(401).json({ message: "Token invalide ou expirÃ©" });
  }
};

// ðŸ”¹ Soumettre une demande de sortie (pour les Ã©tudiants)
router.post(
  "/exit-request",
  authenticateStudent,
  [body("reason").notEmpty().withMessage("La raison est requise").trim().escape()],
  async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) return res.status(400).json({ errors: errors.array() });

    const { reason } = req.body;
    const student = req.user;

    try {
      if (!student.Classe) {
        return res.status(400).json({ message: "Aucune classe assignÃ©e Ã  cet Ã©tudiant" });
      }

      const teacher = await User.findOne({
        Classe: student.Classe,
        Role: "teacher",
      });
      if (!teacher) {
        return res.status(400).json({ message: "Aucun enseignant assignÃ© Ã  votre classe" });
      }

      if (!teacher.enableExitRequestSorting) {
        return res.status(403).json({ message: "L'enseignant n'a pas activÃ© le tri des sorties" });
      }

      const exitRequest = new ExitRequest({
        studentId: student._id,
        teacherId: teacher._id,
        reason,
        priority: calculatePriority(reason),
      });

      await exitRequest.save();

      const pendingRequests = await ExitRequest.find({
        teacherId: teacher._id,
        status: "pending",
      }).sort({ priority: -1, createdAt: 1 });

      const position = pendingRequests.findIndex((req) =>
        req._id.equals(exitRequest._id)
      ) + 1;

      const responseMessage =
        position === 1
          ? "Votre demande est en tÃªte de liste ! Attendez l'approbation de l'enseignant."
          : `Votre demande est en position ${position} dans la liste d'attente.`;

      res.status(201).json({ message: responseMessage, exitRequest });
    } catch (error) {
      console.error("Erreur serveur:", error);
      res.status(500).json({ message: "Erreur interne du serveur" });
    }
  }
);

// ðŸ”¹ Activer/DÃ©sactiver le tri des sorties (enseignant uniquement)
router.put("/toggle-exit-sorting", authenticateTeacher, async (req, res) => {
  try {
    const { enable } = req.body;
    const teacher = req.user;
    teacher.enableExitRequestSorting = enable;
    await teacher.save();
    res.status(200).json({ message: `Tri des sorties ${enable ? "activÃ©" : "dÃ©sactivÃ©"}` });
  } catch (error) {
    console.error("Erreur serveur:", error);
    res.status(500).json({ message: "Erreur interne du serveur" });
  }
});

// ðŸ”¹ Organiser les sorties (enseignant uniquement)
router.post("/organize-exit", authenticateTeacher, async (req, res) => {
  try {
    if (!req.user.enableExitRequestSorting) {
      return res.status(403).json({ message: "Tri des sorties non activÃ©" });
    }
    const requests = await ExitRequest.find({
      teacherId: req.user._id,
      status: "pending",
    });
    const sorted = requests.sort((a, b) => b.priority - a.priority);
    for (let i = 0; i < sorted.length; i++) {
      sorted[i].exitOrder = i + 1;
      await sorted[i].save();
    }
    res.status(200).json({ message: "Sorties organisÃ©es", sortedRequests: sorted });
  } catch (error) {
    console.error("Erreur serveur:", error);
    res.status(500).json({ message: "Erreur interne du serveur" });
  }
});

// ðŸ”¹ Autoriser le prochain (enseignant uniquement)
router.post("/approve-next", authenticateTeacher, async (req, res) => {
  try {
    const next = await ExitRequest.findOne({
      teacherId: req.user._id,
      status: "pending",
    }).sort({ exitOrder: 1 });
    if (!next) return res.status(404).json({ message: "Aucune demande restante" });
    next.status = "approved";
    await next.save();
    res.status(200).json({ message: "Ã‰tudiant autorisÃ© Ã  sortir", studentId: next.studentId });
  } catch (error) {
    console.error("Erreur serveur:", error);
    res.status(500).json({ message: "Erreur interne du serveur" });
  }
});

// ðŸ”¹ RÃ©cupÃ©rer les demandes triÃ©es (enseignant uniquement)
router.get("/exit-requests", authenticateTeacher, async (req, res) => {
  try {
    const requests = await ExitRequest.find({
      teacherId: req.user._id,
      status: "pending",
    }).populate("studentId", "Name");
    const sorted = requests.sort((a, b) => a.exitOrder - b.exitOrder || b.priority - a.priority);
    res.status(200).json({ sortedRequests: sorted });
  } catch (error) {
    console.error("Erreur serveur:", error);
    res.status(500).json({ message: "Erreur interne du serveur" });
  }
});

// ðŸ”¹ Calcul de prioritÃ©
function calculatePriority(reason) {
  const keywords = {
    "urgence mÃ©dicale": 10,
    "toilette": 5,
    "appel urgent": 8,
    "fatigue": 3,
    "autre": 1,
  };
  let priority = 1;
  for (const [key, value] of Object.entries(keywords)) {
    if (reason.toLowerCase().includes(key)) {
      priority = value;
      break;
    }
  }
  return priority;
}

module.exports = router;